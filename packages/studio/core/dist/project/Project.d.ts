import { Func, Procedure, Terminable, TerminableOwner, Terminator, UUID } from "@naomiarotest/lib-std";
import { BoxEditing, BoxGraph } from "@naomiarotest/lib-box";
import { AudioBusBox, AudioUnitBox, BoxIO, RootBox, TimelineBox, UserInterfaceBox } from "@naomiarotest/studio-boxes";
import { BoxAdapters, BoxAdaptersContext, ClipSequencing, ParameterFieldAdapters, ProcessorOptions, ProjectSkeleton, RootBoxAdapter, SampleLoaderManager, SoundfontLoaderManager, TimelineBoxAdapter, UserEditingManager, VertexSelection } from "@naomiarotest/studio-adapters";
import { LiveStreamBroadcaster, LiveStreamReceiver } from "@naomiarotest/lib-fusion";
import { ProjectEnv } from "./ProjectEnv";
import { Mixer } from "../Mixer";
import { ProjectApi } from "./ProjectApi";
import { CaptureDevices } from "../capture";
import { EngineFacade } from "../EngineFacade";
import { EngineWorklet } from "../EngineWorklet";
import { MIDILearning } from "../midi";
import { ppqn, TempoMap } from "@naomiarotest/lib-dsp";
export type RestartWorklet = {
    unload: Func<unknown, Promise<unknown>>;
    load: Procedure<EngineWorklet>;
};
export type ProjectCreateOptions = {
    noDefaultUser?: boolean;
};
export declare class Project implements BoxAdaptersContext, Terminable, TerminableOwner {
    #private;
    static new(env: ProjectEnv, options?: ProjectCreateOptions): Project;
    static load(env: ProjectEnv, arrayBuffer: ArrayBuffer): Project;
    static skeleton(env: ProjectEnv, skeleton: ProjectSkeleton, followFirstUser?: boolean): Project;
    readonly boxGraph: BoxGraph<BoxIO.TypeMap>;
    readonly rootBox: RootBox;
    readonly userInterfaceBoxes: ReadonlyArray<UserInterfaceBox>;
    readonly masterBusBox: AudioBusBox;
    readonly masterAudioUnit: AudioUnitBox;
    readonly timelineBox: TimelineBox;
    readonly api: ProjectApi;
    readonly captureDevices: CaptureDevices;
    readonly editing: BoxEditing;
    readonly selection: VertexSelection;
    readonly boxAdapters: BoxAdapters;
    readonly userEditingManager: UserEditingManager;
    readonly parameterFieldAdapters: ParameterFieldAdapters;
    readonly liveStreamReceiver: LiveStreamReceiver;
    readonly midiLearning: MIDILearning;
    readonly mixer: Mixer;
    readonly tempoMap: TempoMap;
    readonly engine: EngineFacade;
    private constructor();
    startAudioWorklet(restart?: RestartWorklet, options?: ProcessorOptions): EngineWorklet;
    startRecording(countIn?: boolean): void;
    follow(box: UserInterfaceBox): void;
    own<T extends Terminable>(terminable: T): T;
    ownAll<T extends Terminable>(...terminables: Array<T>): void;
    spawn(): Terminator;
    get env(): ProjectEnv;
    get rootBoxAdapter(): RootBoxAdapter;
    get timelineBoxAdapter(): TimelineBoxAdapter;
    get sampleManager(): SampleLoaderManager;
    get soundfontManager(): SoundfontLoaderManager;
    get clipSequencing(): ClipSequencing;
    get isAudioContext(): boolean;
    get isMainThread(): boolean;
    get liveStreamBroadcaster(): LiveStreamBroadcaster;
    get signatureDuration(): ppqn;
    get skeleton(): ProjectSkeleton;
    receivedMIDIFromEngine(midiDeviceId: string, data: Uint8Array, relativeTimeInMs: number): void;
    collectSampleUUIDs(): ReadonlyArray<UUID.Bytes>;
    toArrayBuffer(): ArrayBufferLike;
    copy(env?: Partial<ProjectEnv>): Project;
    invalid(): boolean;
    terminate(): void;
}
//# sourceMappingURL=Project.d.ts.map